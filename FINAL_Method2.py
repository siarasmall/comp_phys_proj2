# -*- coding: utf-8 -*-
"""Project2Compilation.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/123iVqpHhbQxDPV8CE3IA1HP4HpSiYFMd
"""

import numpy as np
from scipy.sparse import diags
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation

"""# Simulation Class"""

class WaveFunctionSimulation:
  def __init__(self, x_start=-10, x_end=10, sim_points=150, dt=0.1, sim_steps=300) -> None:
    '''
    Initializes a WaveFunctionSimulation object with the given
    simulation parameters.

    Params:
      - x_start (int): The starting x-coordinate of the simulation.
      - x_end (int): The ending x-coordinate of the simulation.
      - sim_points (int): The number of x axis points to simulate.
      - dt (int): The time step of the simulation.
      - sim_steps (int): The number of times to evolve the simulation.

    Returns:
      None
    '''
    self.x_start = x_start
    self.x_end = x_end
    self.sim_points = sim_points
    self.dt = dt
    self.sim_steps = sim_steps
    self.evoluton_matrix = None

    # initialize array of x values
    self.x, self.dx = np.linspace(self.x_start, self.x_end, self.sim_points, retstep=True)

  def create_evolution_matrix(self, periodic_boundary, potential_values) -> np.ndarray:
    '''
    Creates a matrix that evolves the wavefunction over time.

    Params:
      - periodic_boundary (bool): Whether to use periodic boundary conditions.
      - potential_values (list): The list of potential values at each x point.

    Returns:
      np.ndarray: The evolution matrix.
    '''
    # create discretized laplacian
    M = diags([np.ones(self.sim_points-1),-2*np.ones(self.sim_points),np.ones(self.sim_points-1)], [-1,0,1]).toarray()

    # make it the boundary conditions periodic
    if periodic_boundary:
      M[0][-1]=1
      M[-1][0]=1

    # create matrix representation of potential
    V = np.diag(potential_values)

    # create Hamiltonian
    const = -1/(2*self.dx**2)
    H = const * M + V
    # self.H = -1 / (2 * (self.dx**2)) * M + V
    # create identity matrix
    I = np.identity(self.sim_points)
    # create operator pair
    h1 = I - (1j * self.dt * 0.5 * H)
    h2 = I + (1j * self.dt * 0.5 * H)
    # invert operator (to solve for next wavefunction)
    h2_inv = np.linalg.inv(h2)

    return np.matmul(h2_inv, h1)

  def create_wavepacket(self, wave_center, wave_width, wave_momentum) -> np.ndarray:
    '''
    Creates a wavepacket with the given parameters.

    Params:
      - wave_center (int): The x position of the center of the initial wavepacket.
      - wave_width (int): The width of the initial wavepacket.
      - wave_momentum (int): The momentum of the initial wavepacket.

    Returns:
      np.ndarray: The initial wavepacket.
    '''
    A = (2 * np.pi * wave_width**2)**(-0.25)
    return A * np.exp(1j*wave_momentum*self.x - ((self.x - wave_center)/(2 * wave_width))**2)

  def step(self, wavefunction) -> np.ndarray:
    '''
    Evolves the wavefunction over one time step.

    Params:
      - wavefunction (np.ndarray): The current wavefunction.

    Returns:
      np.ndarray: The evolved wavefunction.
    '''
    return np.matmul(self.evoluton_matrix, wavefunction)

  def simulate(self, periodic_boundary, potential_values, wave_center, wave_width, wave_momentum) -> np.ndarray:
    '''
    Simulates a wave function in the given potential values.

    Params:
      - periodic_boundary (bool): Whether to use periodic boundary conditions.
      - potential_values (list): The list of potential values at each x point.
      - wave_center (int): The x position of the center of the initial wavepacket.
      - wave_width (int): The width of the initial wavepacket.
      - wave_momentum (int): The momentum of the initial wavepacket.

    Returns:
      np.ndarray: An array of the wavefunction values at each time point.
    '''
    # create evolution matrix. Multiply this matrix by previous wavefunction
    # to get the next wavefunction
    self.evoluton_matrix = self.create_evolution_matrix(periodic_boundary, potential_values)

    # create array to store wavefunctions
    wavefunctions = []

    # create initial wavepacket
    wavefunctions.append(self.create_wavepacket(wave_center, wave_width, wave_momentum))

    # evolve wavepacket
    for i in range(self.sim_steps-1):
      wavefunctions.append(self.step(wavefunctions[-1]))

    return np.array(wavefunctions)

  def get_sim_vars(self) -> tuple:
    '''
    Returns the simulation variables.

    Params:
      None

    Returns:
      tuple: (x, x_start, x_end, dx, dt, sim_points, sim_steps).
    '''
    return self.x, self.x_start, self.x_end, self.dx, self.dt, self.sim_points, self.sim_steps

"""# Potentials Class"""

class Potential:
    def __init__(self, mags, total_num) -> None:
        """
        Inits a Potential object.

        Params:
            - Mags (np array of ints): Magnitudes of x values
            - Total_num (int): total number of x values
        """
        self.mags = mags
        self.matrix = np.diagflat(mags)
        self.total_num = total_num

    def getMatrix(self):
        return self.matrix

    def getMagnitudes(self):
        return self.mags

class PotentialWithBarriers(Potential):
    def __init__(self, data, total_num) -> None:
        """
        Inits a Potential object with barriers.

        Params:
            - data: List of tuples (start, stop, mag) representing the start index, stop index,
            and magnitude of each "barrier"/block
        """
        # V = np.zeros([total_num])
        # for start, stop, mag in data:
        #     for i in range (start, stop):
        #         V[i] = mag
        V = data
        super().__init__(V, total_num)

class Barrier(PotentialWithBarriers):
    def __init__(self, start, stop, y0, a, total_num, x) -> None:
        """
        Inits a Potential barrier.

        Params:
            - Start (int): start index of barrier
            - Stop (int): stop index of barrier
            - y0 (int): initial height (pre-barrier)
            - a (int): height of barrier (NOT total height with barrier)
            - Total_num (int): total number of x values
            - x (list): list of x values
        """
        # data = [(0, start, y0), (start, stop, y0 + a), (stop, total_num, y0)]
        data = [y0 if x[i]-start < 0 or stop-x[i] < 0 else y0+a for i in range(len(x))]
        super().__init__(data, total_num)

class InfiniteSquareWell(PotentialWithBarriers):
    def __init__(self, start, stop, y0, total_num, x) -> None:
        """
        Inits an infinite square well potential.

        Params:
            - Start (int): start index of well
            - Stop (int): stop index of well
            - y0 (int): initial height (pre-well)
            - Total_num (int): total number of x values
        """
        # data = [(0, start, y0), (start, stop, -np.inf), (stop, total_num, y0)]
        data = [y0 if x[i]-start < 0 or stop-x[i] < 0 else -10000 for i in range(len(x))]
        super().__init__(data, total_num)

class FiniteSquareWell(PotentialWithBarriers):
    def __init__(self, start, stop, y0, a, total_num, x) -> None:
        """
        Inits a finite square well potential.

        Params:
            - Start (int): start index of well
            - Stop (int): stop index of well
            - y0 (int): initial height (pre-well)
            - a (int): depth of well (NOT total height with well)
            - Total_num (int): total number of x values
        """
        # data = [(0, start, y0), (start, stop, y0 - a), (stop, total_num, y0)]
        data = [y0 if x[i]-start < 0 or stop-x[i] < 0 else y0-a for i in range(len(x))]
        super().__init__(data, total_num)

class FreeParticle(Potential):
    def __init__(self, total_num) -> None:
        super().__init__(np.zeros(total_num), total_num)

class TriangleWell(Potential):
    pass

class SimpleHarmonicOscillator(Potential):
    def __init__(self, x, center, w) -> None:
        """
        Inits quantum harmonic potential.

        Params:
            - x (list): list of x values
            - center (int): center of harmonic potential
            - w (int): frequency of harmonic potential
        """
        super().__init__(0.5 * (w*w) * (x-center)**2, len(x))

class Kronig_Penney(Potential):
    def __init__(self, x, beg, width, height, gap, N) -> None:
      '''
        Creates a periodic array of potential barriers.

        Params:
          - x (list): list of x values
          - start_x (float): the starting x value where the first barrier will begin
          - width (int): width of Kronig-Penney potential
          - height (int): height of Kronig-Penney potential
          - gap (int): gap between successive barriers
          - N (int): number of barriers
      '''
      data = np.zeros([len(x)])

      for i in range(N):
        start = beg + i * gap
        stop = start + width
        data += Barrier(start, stop, 0, height, len(x), x).getMagnitudes()

      super().__init__(data, len(x))

class ImaginaryPotential(Potential):
  def __init__(self, x, L) -> None:
    data = [1j*x[i] if -L < x[i] < L else 10000 for i in range(len(x))]
    super().__init__(data, len(x))

"""# Animation Class"""

class Animation:
  # allow for html embedded animations, and import matplotlib
  from matplotlib import rc
  rc('animation', html='jshtml')

  import matplotlib.pyplot as plt
  import matplotlib.animation as anim

  def __init__(self, names: list[str], xlim: tuple, ylim: tuple):
    if not isinstance(names, list):
      raise TypeError("names must be a list of strings")
    for name in names:
      if not isinstance(name, str):
        raise TypeError("names must be a list of strings")
    if not isinstance(xlim, tuple) or len(xlim) != 2:
      raise TypeError("xlim must be a 2-tuple of floats")
    if not isinstance(ylim, tuple) or len(ylim) != 2:
      raise TypeError("ylim must be a 2-tuple of floats")

    # set up plot
    self.fig, self.ax = Animation.plt.subplots()

    self.lines = []
    self.color = ['b', 'g', 'k', 'r']
    self.alpha = [0.8, 0.8, 1, 0.6]
    for i in range(len(names)):
      line, = self.ax.plot([], [], self.color[i], lw=3, alpha=self.alpha[i])
      self.lines.append(line)

    self.ax.legend([ line for line in self.lines ], [ name for name in names ])
    self.ax.set_xlim(xlim[0], xlim[1])
    self.ax.set_ylim(ylim[0], ylim[1])

    # for some reason subplots() is showing a plot, so hide as not required
    self.plt.close()

  def set_data(self, lineNum: int, x: list[float], y: list[float]):
    self.lines[lineNum].set_data(x, y)

  # func: (frame: int) -> a.lines
  def set_anim_func(self, func):
    self.func = func

  # frames = number of frames
  # interval = time between frames in ms
  def make_anim(self, frames: int, interval: int, blit: bool):
    self.anim = Animation.anim.FuncAnimation(self.fig,
                                             self.func,
                                             frames=frames,
                                             interval=interval,
                                             blit=blit)
    return self.anim

  # unable to have a "show()" function with html embed, so just save the output
  # of make_anim to a variable and type the name of that variable to show
  #
  # ex:
  #   >>> ani = a.make_anim(frames=100, interval=20, blit=True)
  #   >>> ani

  def save(self, path: str):
    if not isinstance(path, str):
      raise TypeError("path must be a string")
    self.anim.save(path)

"""# Animation Loop Function"""

def animate_simulation(x, sim_data, potential_values, frames):

  a = Animation(['Re(Ψ)', 'Im(Ψ)', '|Ψ|^2', 'Potential'], (x[0], x[-1]), (-0.5, 0.5))

  # define an "animate" function which takes in the integer frame number,
  # calls Animation.set_data to data and returns Animation.lines
  def animate1(i):
    a.set_data(0, x, sim_data[i].real)
    a.set_data(1, x, sim_data[i].imag)
    a.set_data(2, x, sim_data[i].real**2 + sim_data[i].imag**2)
    a.set_data(3, x, potential_values)
    return a.lines

  # set the animate function and make the animation
  a.set_anim_func(animate1)
  ani1 = a.make_anim(frames=frames, interval=20, blit=True)
  return ani1

"""# How it works

**Initialize a WavefunctionSimulation object with animation properties:**

    simulation = WavefunctionSimulation([beginning x axis value], [ending x axis value], [number of x axis points], [simulation time step], [number of time steps])

**You can retrieve these animation properties and the x axis values using a class function:**

    x_values, starting_x, ending_x, dx, dt, simulation_points, simulation_steps = WavefunctionSimulation.get_sim_vars()

**Initialize a potential using the potential classes**

    potential = [Barrier, InfiniteSquareWell, FiniteSquareWell, FreeParticle, TriangleWell, SimpleHarmonicOscillator, Kronig_Penney, ImaginaryPotential]

**Get the array representation of this potential using the potential class function:**

    potential_array = potential.getMagnitudes()

**Use the simulate function from the WavefunctionSimulation class to run the simulation:**\
    *Specify the boundary conditions, potential, and initial wavepacket values*

    simulated_wavefunctions = simulation.simulate([Periodic Boundary Conditions], [potential_aryay], [wavepacket center], [wavepacket width], [wavepacket momentum])

**Use the animate_simulation function to draw the animation:**
    
    anim = animate_simulation(x_values, simulated_wavefunctions, potential_array, simulation_steps)

**Type "anim" in a jupyter notebook to show the animation or save a file of it:**
    
    "anim" (for jupyter notebook)
        or
    anim.save("path/to/file.mp4") (for download)

# Example
"""

# Initialize simulation object
Simulation = WaveFunctionSimulation(-20, 20, 300, 0.1, 400)
X_VALUES, X_START, X_END, DX, DT, SIM_POINTS, SIM_STEPS = Simulation.get_sim_vars()

"""### Free Particle"""

# initialize potential
zero_potential = FreeParticle(SIM_POINTS)
potential_values = zero_potential.getMagnitudes()

free_particle_sim = Simulation.simulate(True, potential_values, -5, 1, 2)

ani1 = animate_simulation(X_VALUES, free_particle_sim, potential_values, SIM_STEPS)

ani1

"""### Potential Barrier"""

potential_barrier = Barrier(3, 5, 0, 3, SIM_POINTS, X_VALUES)
potential_values = potential_barrier.getMagnitudes()

barrier_sim = Simulation.simulate(True, potential_values, -12, 1, 2)

ani1 = animate_simulation(X_VALUES, barrier_sim, potential_values, SIM_STEPS)

ani1

"""### Finite Square Well (creates an eigenstate)"""

finite_well = FiniteSquareWell(-5, 5, 0, 3, SIM_POINTS, X_VALUES)
potential_values = finite_well.getMagnitudes()

free_particle_sim = Simulation.simulate(True, potential_values, 0, 1, 0)

a = Animation(['Re(Ψ)', 'Im(Ψ)', '|Ψ|^2', 'Potential'], (X_START, X_END), (-0.5, 0.5))

# define an "animate" function which takes in the integer frame number,
# calls Animation.set_data to data and returns Animation.lines
def animate1(i):
  a.set_data(0, X_VALUES, free_particle_sim[i].real)
  a.set_data(1, X_VALUES, free_particle_sim[i].imag)
  a.set_data(2, X_VALUES, free_particle_sim[i].real**2 + free_particle_sim[i].imag**2)
  a.set_data(3, X_VALUES, potential_values)
  return a.lines

# set the animate function and make the animation
a.set_anim_func(animate1)
ani1 = a.make_anim(frames=SIM_STEPS, interval=20, blit=True)

ani1

"""### Infinite Square Well (creates a stationary state)"""

infinite_well = InfiniteSquareWell(-5, 5, 0, SIM_POINTS, X_VALUES)
potential_values = infinite_well.getMagnitudes()

free_particle_sim = Simulation.simulate(True, potential_values, 0, 1, 0)

a = Animation(['Re(Ψ)', 'Im(Ψ)', '|Ψ|^2', 'Potential'], (X_START, X_END), (-0.5, 0.5))

# define an "animate" function which takes in the integer frame number,
# calls Animation.set_data to data and returns Animation.lines
def animate1(i):
  a.set_data(0, X_VALUES, free_particle_sim[i].real)
  a.set_data(1, X_VALUES, free_particle_sim[i].imag)
  a.set_data(2, X_VALUES, free_particle_sim[i].real**2 + free_particle_sim[i].imag**2)
  a.set_data(3, X_VALUES, potential_values)
  return a.lines

# set the animate function and make the animation
a.set_anim_func(animate1)
ani1 = a.make_anim(frames=SIM_STEPS, interval=20, blit=True)

ani1

"""### Harmonic Oscillator"""

quantum_SHO = SimpleHarmonicOscillator(X_VALUES, 0, 0.1)
potential_values = quantum_SHO.getMagnitudes()

free_particle_sim = Simulation.simulate(True, potential_values, 0, 1, 0)

a = Animation(['Re(Ψ)', 'Im(Ψ)', '|Ψ|^2', 'Potential'], (X_START, X_END), (-0.5, 0.5))

# define an "animate" function which takes in the integer frame number,
# calls Animation.set_data to data and returns Animation.lines
def animate1(i):
  a.set_data(0, X_VALUES, free_particle_sim[i].real)
  a.set_data(1, X_VALUES, free_particle_sim[i].imag)
  a.set_data(2, X_VALUES, free_particle_sim[i].real**2 + free_particle_sim[i].imag**2)
  a.set_data(3, X_VALUES, potential_values)
  return a.lines

# set the animate function and make the animation
a.set_anim_func(animate1)
ani1 = a.make_anim(frames=SIM_STEPS, interval=20, blit=True)

ani1

quantum_SHO = SimpleHarmonicOscillator(X_VALUES, 0, 0.5)
potential_values = quantum_SHO.getMagnitudes()

free_particle_sim = Simulation.simulate(True, potential_values, -5, 1, 0)

a = Animation(['Re(Ψ)', 'Im(Ψ)', '|Ψ|^2', 'Potential'], (X_START, X_END), (-0.5, 0.5))

# define an "animate" function which takes in the integer frame number,
# calls Animation.set_data to data and returns Animation.lines
def animate1(i):
  a.set_data(0, X_VALUES, free_particle_sim[i].real)
  a.set_data(1, X_VALUES, free_particle_sim[i].imag)
  a.set_data(2, X_VALUES, free_particle_sim[i].real**2 + free_particle_sim[i].imag**2)
  a.set_data(3, X_VALUES, potential_values)
  return a.lines

# set the animate function and make the animation
a.set_anim_func(animate1)
ani1 = a.make_anim(frames=SIM_STEPS, interval=20, blit=True)

ani1

"""### Kronig-Penney"""

kronig_penney = Kronig_Penney(X_VALUES, -20, 1, 1, 4, 10)
potential_values = kronig_penney.getMagnitudes()

free_particle_sim = Simulation.simulate(True, potential_values, -10, 1, 3)

a = Animation(['Re(Ψ)', 'Im(Ψ)', '|Ψ|^2', 'Potential'], (X_START, X_END), (-0.5, 0.5))

# define an "animate" function which takes in the integer frame number,
# calls Animation.set_data to data and returns Animation.lines
def animate1(i):
  a.set_data(0, X_VALUES, free_particle_sim[i].real)
  a.set_data(1, X_VALUES, free_particle_sim[i].imag)
  a.set_data(2, X_VALUES, free_particle_sim[i].real**2 + free_particle_sim[i].imag**2)
  a.set_data(3, X_VALUES, potential_values)
  return a.lines

# set the animate function and make the animation
a.set_anim_func(animate1)
ani1 = a.make_anim(frames=SIM_STEPS, interval=20, blit=True)

ani1

"""### Imaginary Potential"""

imag_pot = ImaginaryPotential(X_VALUES, 10)
potential_values = np.array(imag_pot.getMagnitudes())

free_particle_sim = Simulation.simulate(True, potential_values, 0, 1, 0)

a = Animation(['Re(Ψ)', 'Im(Ψ)', '|Ψ|^2', 'Im(Potential)'], (X_START, X_END), (-0.5, 0.5))

# define an "animate" function which takes in the integer frame number,
# calls Animation.set_data to data and returns Animation.lines
def animate1(i):
  a.set_data(0, X_VALUES, free_particle_sim[i].real)
  a.set_data(1, X_VALUES, free_particle_sim[i].imag)
  a.set_data(2, X_VALUES, free_particle_sim[i].real**2 + free_particle_sim[i].imag**2)
  a.set_data(3, X_VALUES, potential_values.imag)
  return a.lines

# set the animate function and make the animation
a.set_anim_func(animate1)
ani1 = a.make_anim(frames=SIM_STEPS, interval=20, blit=True)

ani1

