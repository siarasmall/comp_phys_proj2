# -*- coding: utf-8 -*-
"""Project2Compilation.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/123iVqpHhbQxDPV8CE3IA1HP4HpSiYFMd
"""

import numpy as np
from scipy.sparse import diags
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation

"""# Simulation Class"""

class WaveFunctionSimulation:
  def __init__(self, x_start=0, x_end=100, sim_points=500, dt=100, sim_steps=300) -> None:
    '''
    Initializes a WaveFunctionSimulation object with the given
    simulation parameters.

    Params:
      - x_start (int): The starting x-coordinate of the simulation.
      - x_end (int): The ending x-coordinate of the simulation.
      - sim_points (int): The number of x axis points to simulate.
      - dt (int): The time step of the simulation.
      - sim_steps (int): The number of times to evolve the simulation.

    Returns:
      None
    '''
    self.x_start = x_start
    self.x_end = x_end
    self.sim_points = sim_points
    self.dt = dt
    self.sim_steps = sim_steps
    self.evoluton_matrix = None

    # initialize array of x values
    self.x, self.dx = np.linspace(self.x_start, self.x_end, self.sim_points, retstep=True)

  def create_evolution_matrix(self, periodic_boundary, potential_values) -> np.ndarray:
    '''
    Creates a matrix that evolves the wavefunction over time.

    Params:
      - periodic_boundary (bool): Whether to use periodic boundary conditions.
      - potential_values (list): The list of potential values at each x point.

    Returns:
      np.ndarray: The evolution matrix.
    '''
    # create discretized laplacian
    M = diags([np.ones(self.sim_points-1),-2*np.ones(self.sim_points),np.ones(self.sim_points-1)], [-1,0,1]).toarray()
    # make it the boundary conditions periodic
    if periodic_boundary:
      M[0][-1]=1
      M[-1][0]=1

    # create matrix representation of potential
    V = np.diag(potential_values)

    # create Hamiltonian
    H = -0.5 * (self.dx*self.dx) * M + V
    # create identity matrix
    I = np.identity(self.sim_points)
    # create operator pair
    h1 = I - (1j * self.dt * 0.5 * H)
    h2 = I + (1j * self.dt * 0.5 * H)
    # invert operator (to solve for next wavefunction)
    h2_inv = np.linalg.inv(h2)

    return np.matmul(h2_inv, h1)

  def create_wavepacket(self, wave_center, wave_width, wave_momentum) -> np.ndarray:
    '''
    Creates a wavepacket with the given parameters.

    Params:
      - wave_center (int): The x position of the center of the initial wavepacket.
      - wave_width (int): The width of the initial wavepacket.
      - wave_momentum (int): The momentum of the initial wavepacket.

    Returns:
      np.ndarray: The initial wavepacket.
    '''
    A = (2 * np.pi * wave_width**2)**(-0.25)
    return A * np.exp(1j*wave_momentum*self.x - ((self.x - wave_center)/(2 * wave_width))**2)

  def step(self, wavefunction) -> np.ndarray:
    '''
    Evolves the wavefunction over one time step.

    Params:
      - wavefunction (np.ndarray): The current wavefunction.

    Returns:
      np.ndarray: The evolved wavefunction.
    '''
    return np.matmul(self.evoluton_matrix, wavefunction)

  def simulate(self, periodic_boundary, potential_values, wave_center, wave_width, wave_momentum) -> np.ndarray:
    '''
    Simulates a wave function in the given potential values.

    Params:
      - periodic_boundary (bool): Whether to use periodic boundary conditions.
      - potential_values (list): The list of potential values at each x point.
      - wave_center (int): The x position of the center of the initial wavepacket.
      - wave_width (int): The width of the initial wavepacket.
      - wave_momentum (int): The momentum of the initial wavepacket.

    Returns:
      np.ndarray: An array of the wavefunction values at each time point.
    '''
    # create evolution matrix. Multiply this matrix by previous wavefunction
    # to get the next wavefunction
    self.evoluton_matrix = self.create_evolution_matrix(periodic_boundary, potential_values)

    # create array to store wavefunctions
    wavefunctions = []

    # create initial wavepacket
    wavefunctions.append(self.create_wavepacket(wave_center, wave_width, wave_momentum))

    # evolve wavepacket
    for i in range(self.sim_steps-1):
      wavefunctions.append(self.step(wavefunctions[-1]))

    return np.array(wavefunctions)

  def get_sim_vars(self) -> tuple:
    '''
    Returns the simulation variables.

    Params:
      None

    Returns:
      tuple: (x, x_start, x_end, dx, dt, sim_points, sim_steps).
    '''
    return self.x, self.x_start, self.x_end, self.dx, self.dt, self.sim_points, self.sim_steps

"""# Potentials Class"""

class Potential:
    def __init__(self, mags, total_num) -> None:
        """
        Inits a Potential object.

        Params:
            - Mags (np array of ints): Magnitudes of x values
            - Total_num (int): total number of x values
        """
        self.mags = mags
        self.matrix = np.diagflat(mags)
        self.total_num = total_num

    def getMatrix(self):
        return self.matrix

    def getMagnitudes(self):
        return self.mags

class PotentialWithBarriers(Potential):
    def __init__(self, data, total_num) -> None:
        """
        Inits a Potential object with barriers.

        Params:
            - data: List of tuples (start, stop, mag) representing the start index, stop index,
            and magnitude of each "barrier"/block
        """
        V = np.zeros([total_num])
        for start, stop, mag in data:
            for i in range (start, stop):
                V[i] = mag
        super().__init__(V, total_num)

class Barrier(PotentialWithBarriers):
    def __init__(self, start, stop, y0, a, total_num) -> None:
        """
        Inits a Potential barrier.

        Params:
            - Start (int): start index of barrier
            - Stop (int): stop index of barrier
            - y0 (int): initial height (pre-barrier)
            - a (int): height of barrier (NOT total height with barrier)
            - Total_num (int): total number of x values
        """
        data = [(0, start, y0), (start, stop, y0 + a), (stop, total_num, y0)]
        super().__init__(data, total_num)

class InfiniteSquareWell(PotentialWithBarriers):
    def __init__(self, start, stop, y0, total_num) -> None:
        """
        Inits an infinite square well potential.

        Params:
            - Start (int): start index of well
            - Stop (int): stop index of well
            - y0 (int): initial height (pre-well)
            - Total_num (int): total number of x values
        """
        data = [(0, start, y0), (start, stop, -np.inf), (stop, total_num, y0)]
        super().__init__(data, total_num)

class FiniteSquareWell(PotentialWithBarriers):
    def __init__(self, start, stop, y0, a, total_num) -> None:
        """
        Inits a finite square well potential.

        Params:
            - Start (int): start index of well
            - Stop (int): stop index of well
            - y0 (int): initial height (pre-well)
            - a (int): depth of well (NOT total height with well)
            - Total_num (int): total number of x values
        """
        data = [(0, start, y0), (start, stop, y0 - a), (stop, total_num, y0)]
        super().__init__(data, total_num)

class FreeParticle(Potential):
    def __init__(self, total_num) -> None:
        super().__init__(np.zeros(total_num), total_num)

class TriangleWell(Potential):
    pass

class SimpleHarmonicOscillator(Potential):
    def __init__(self, x, center, w) -> None:
        """
        Inits quantum harmonic potential.

        Params:
            - x (list): list of x values
            - center (int): center of harmonic potential
            - w (int): frequency of harmonic potential
        """
        super().__init__(0.5 * (w*w) * (x-center)**2, len(x))

"""# Animation Class"""

class Animation:
  # allow for html embedded animations, and import matplotlib
  from matplotlib import rc
  rc('animation', html='jshtml')

  import matplotlib.pyplot as plt
  import matplotlib.animation as anim

  def __init__(self, names: list[str], xlim: tuple, ylim: tuple):
    if not isinstance(names, list):
      raise TypeError("names must be a list of strings")
    for name in names:
      if not isinstance(name, str):
        raise TypeError("names must be a list of strings")
    if not isinstance(xlim, tuple) or len(xlim) != 2:
      raise TypeError("xlim must be a 2-tuple of floats")
    if not isinstance(ylim, tuple) or len(ylim) != 2:
      raise TypeError("ylim must be a 2-tuple of floats")

    # set up plot
    self.fig, self.ax = Animation.plt.subplots()

    self.lines = []
    self.color = ['b', 'g', 'k', 'r']
    self.alpha = [0.8, 0.8, 1, 0.6]
    for i in range(len(names)):
      line, = self.ax.plot([], [], self.color[i], lw=3, alpha=self.alpha[i])
      self.lines.append(line)

    self.ax.legend([ line for line in self.lines ], [ name for name in names ])
    self.ax.set_xlim(xlim[0], xlim[1])
    self.ax.set_ylim(ylim[0], ylim[1])

    # for some reason subplots() is showing a plot, so hide as not required
    self.plt.close()

  def set_data(self, lineNum: int, x: list[float], y: list[float]):
    self.lines[lineNum].set_data(x, y)

  # func: (frame: int) -> a.lines
  def set_anim_func(self, func):
    self.func = func

  # frames = number of frames
  # interval = time between frames in ms
  def make_anim(self, frames: int, interval: int, blit: bool):
    self.anim = Animation.anim.FuncAnimation(self.fig,
                                             self.func,
                                             frames=frames,
                                             interval=interval,
                                             blit=blit)
    return self.anim

  # unable to have a "show()" function with html embed, so just save the output
  # of make_anim to a variable and type the name of that variable to show
  #
  # ex:
  #   >>> ani = a.make_anim(frames=100, interval=20, blit=True)
  #   >>> ani

  def save(self, path: str):
    if not isinstance(path, str):
      raise TypeError("path must be a string")
    self.anim.save(path)

"""# Putting Everything Together"""

# Initialize simulation object
Simulation = WaveFunctionSimulation(-10, 10, 150, 100, 400)
X_VALUES, X_START, X_END, DX, DT, SIM_POINTS, SIM_STEPS = Simulation.get_sim_vars()

"""### Free Particle"""

# initialize potential
zero_potential = FreeParticle(SIM_POINTS)
potential_values = zero_potential.getMagnitudes()

free_particle_sim = Simulation.simulate(True, potential_values, -5, 1, 2)

a = Animation(['Re(Ψ)', 'Im(Ψ)', '|Ψ|^2', 'Potential'], (X_START, X_END), (-0.5, 0.5))

# define an "animate" function which takes in the integer frame number,
# calls Animation.set_data to data and returns Animation.lines
def animate1(i):
  a.set_data(0, X_VALUES, free_particle_sim[i].real)
  a.set_data(1, X_VALUES, free_particle_sim[i].imag)
  a.set_data(2, X_VALUES, free_particle_sim[i].real**2 + free_particle_sim[i].imag**2)
  a.set_data(3, X_VALUES, potential_values)
  return a.lines

# set the animate function and make the animation
a.set_anim_func(animate1)
ani1 = a.make_anim(frames=SIM_STEPS, interval=20, blit=True)

ani1

"""### Potential Barrier"""

potential_barrier = Barrier(round(5/dx), round(5.1/dx), 0, 0.2, SIM_POINTS)
potential_values = potential_barrier.getMagnitudes()

free_particle_sim = Simulation.simulate(True, potential_values, -5, 1, 2)

a = Animation(['Re(Ψ)', 'Im(Ψ)', '|Ψ|^2', 'Potential'], (X_START, X_END), (-0.5, 0.5))

# define an "animate" function which takes in the integer frame number,
# calls Animation.set_data to data and returns Animation.lines
def animate1(i):
  a.set_data(0, X_VALUES, free_particle_sim[i].real)
  a.set_data(1, X_VALUES, free_particle_sim[i].imag)
  a.set_data(2, X_VALUES, free_particle_sim[i].real**2 + free_particle_sim[i].imag**2)
  a.set_data(3, X_VALUES, potential_values)
  return a.lines

# set the animate function and make the animation
a.set_anim_func(animate1)
ani1 = a.make_anim(frames=SIM_STEPS, interval=20, blit=True)

ani1

